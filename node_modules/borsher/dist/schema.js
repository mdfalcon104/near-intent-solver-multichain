"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.BorshSchema = void 0;
const buffer_1 = require("buffer");
const borsh = __importStar(require("borsh"));
class BorshSchema {
    schema;
    constructor(schema) {
        this.schema = schema;
    }
    static fromSchemaUnchecked(schema) {
        return new BorshSchema(schema);
    }
    toSchema() {
        return this.schema;
    }
    serialize(value) {
        const buffer = borsh.serialize(this.toSchema(), value);
        return buffer_1.Buffer.from(buffer);
    }
    deserialize(buffer) {
        const value = borsh.deserialize(this.toSchema(), buffer);
        return value;
    }
    /**
     * Schema for u8
     * @example
     * const schema = BorshSchema.u8;
     * const n: number = 100;
     * const buffer = schema.serialize(n);
     */
    static get u8() {
        return BorshSchema.fromSchemaUnchecked('u8');
    }
    /**
     * Schema for u16
     * @example
     * const schema = BorshSchema.u16;
     * const n: number = 100;
     * const buffer = schema.serialize(n);
     */
    static get u16() {
        return BorshSchema.fromSchemaUnchecked('u16');
    }
    /**
     * Schema for u32
     * @example
     * const schema = BorshSchema.u32;
     * const n: number = 100;
     * const buffer = schema.serialize(n);
     */
    static get u32() {
        return BorshSchema.fromSchemaUnchecked('u32');
    }
    /**
     * Schema for u64
     * @example
     * const schema = BorshSchema.u64;
     * const n: bigint = 100n;
     * const buffer = schema.serialize(n);
     */
    static get u64() {
        return BorshSchema.fromSchemaUnchecked('u64');
    }
    /**
     * Schema for u128
     * @example
     * const schema = BorshSchema.u128;
     * const n: bigint = 100n;
     * const buffer = schema.serialize(n);
     */
    static get u128() {
        return BorshSchema.fromSchemaUnchecked('u128');
    }
    /**
     * Schema for i8
     * @example
     * const schema = BorshSchema.i8;
     * const n: number = 100;
     * const buffer = schema.serialize(n);
     */
    static get i8() {
        return BorshSchema.fromSchemaUnchecked('i8');
    }
    /**
     * Schema for i16
     * @example
     * const schema = BorshSchema.i16;
     * const n: number = 100;
     * const buffer = schema.serialize(n);
     */
    static get i16() {
        return BorshSchema.fromSchemaUnchecked('i16');
    }
    /**
     * Schema for i32
     * @example
     * const schema = BorshSchema.i32;
     * const n: number = 100;
     * const buffer = schema.serialize(n);
     */
    static get i32() {
        return BorshSchema.fromSchemaUnchecked('i32');
    }
    /**
     * Schema for i64
     * @example
     * const schema = BorshSchema.i64;
     * const n: bigint = 100n;
     * const buffer = schema.serialize(n);
     */
    static get i64() {
        return BorshSchema.fromSchemaUnchecked('i64');
    }
    /**
     * Schema for i128
     * @example
     * const schema = BorshSchema.i128;
     * const n: bigint = 100n;
     * const buffer = schema.serialize(n);
     */
    static get i128() {
        return BorshSchema.fromSchemaUnchecked('i128');
    }
    /**
     * Schema for f32
     * @example
     * const schema = BorshSchema.f32;
     * const n: number = 1.0;
     * const buffer = schema.serialize(n);
     */
    static get f32() {
        return BorshSchema.fromSchemaUnchecked('f32');
    }
    /**
     * Schema for f64
     * @example
     * const schema = BorshSchema.f64;
     * const n: number = 1.0;
     * const buffer = schema.serialize(n);
     */
    static get f64() {
        return BorshSchema.fromSchemaUnchecked('f64');
    }
    /**
     * Schema for bool
     * @example
     * const schema = BorshSchema.bool;
     * const b: boolean = true;
     * const buffer = schema.serialize(b);
     */
    static get bool() {
        return BorshSchema.fromSchemaUnchecked('bool');
    }
    /**
     * Schema for String
     * @example
     * const schema = BorshSchema.String;
     * const message: string = 'hello world';
     * const buffer = schema.serialize(message);
     */
    static get String() {
        return BorshSchema.fromSchemaUnchecked('string');
    }
    /**
     * Schema for Option
     * @example
     * const schema = BorshSchema.Option(BorshSchema.String);
     *
     * const some: string | null = 'hello world';
     * const someBuffer = schema.serialize(some);
     *
     * const none: string | null = null;
     * const noneBuffer = schema.serialize(none);
     */
    static Option(value) {
        return BorshSchema.fromSchemaUnchecked({ option: value.toSchema() });
    }
    /**
     * Schema for Array
     * @example
     * const schema = BorshSchema.Array(BorshSchema.String, 2);
     * const messages: string[] = ['hello', 'world'];
     * const buffer = schema.serialize(messages);
     */
    static Array(value, length) {
        return BorshSchema.fromSchemaUnchecked({
            array: { type: value.toSchema(), len: length },
        });
    }
    /**
     * Schema for Vec
     * @example
     * const schema = BorshSchema.Vec(BorshSchema.String);
     * const messages: string[] = ['hello', 'world'];
     * const buffer = schema.serialize(messages);
     */
    static Vec(value) {
        return BorshSchema.fromSchemaUnchecked({
            array: { type: value.toSchema() },
        });
    }
    /**
     * Schema for HashSet
     * @example
     * const schema = BorshSchema.HashSet(BorshSchema.String);
     * const messages: Set<string> = new Set(['hello', 'world']);
     * const buffer = schema.serialize(messages);
     */
    static HashSet(value) {
        return BorshSchema.fromSchemaUnchecked({ set: value.toSchema() });
    }
    /**
     * Schema for HashMap
     * @example
     * const schema = BorshSchema.HashMap(BorshSchema.String, BorshSchema.u128);
     * const balances: Map<string, bigint> = new Map([
     *   ['alice', 1_000_000_000_000_000_000_000_000n],
     *   ['bob', 2_000_000_000_000_000_000_000_000n],
     * ]);
     * const buffer = schema.serialize(balances);
     */
    static HashMap(key, value) {
        return BorshSchema.fromSchemaUnchecked({
            map: { key: key.toSchema(), value: value.toSchema() },
        });
    }
    /**
     * Schema for Unit
     * @example
     * const schema = BorshSchema.Unit;
     * const unit: Unit = {};
     * const buffer = schema.serialize(unit);
     */
    static get Unit() {
        return BorshSchema.Struct({});
    }
    /**
     * Schema for Struct
     * @example
     * const schema = BorshSchema.Struct({
     *   name: BorshSchema.String,
     *   age: BorshSchema.u8,
     * });
     *
     * type Person = Infer<typeof schema>;
     *
     * // type Person = {
     * //   name: string;
     * //   age: number;
     * // };
     *
     * const person: Person = {
     *   name: 'alice',
     *   age: 18,
     * };
     *
     * const buffer = schema.serialize(person);
     */
    static Struct(fields) {
        const schema = BorshSchema.parseStructSchema(fields);
        return BorshSchema.fromSchemaUnchecked(schema);
    }
    /**
     * Schema for Enum
     * @example
     * const schema = BorshSchema.Enum({
     *   Pending: BorshSchema.Unit,
     *   Fulfilled: BorshSchema.Unit,
     *   Rejected: BorshSchema.Unit,
     * });
     *
     * type Status = Infer<typeof schema>;
     *
     * // type Status =
     * //   | {
     * //   Pending: Unit;
     * // }
     * //   | {
     * //   Fulfilled: Unit;
     * // }
     * //   | {
     * //   Rejected: Unit;
     * // };
     *
     * const status: Status = {
     *   Pending: {},
     * };
     *
     * const buffer = schema.serialize(status);
     *
     * @example
     * const schema = BorshSchema.Enum({
     *   Square: BorshSchema.u32,
     *   Rectangle: BorshSchema.Struct({
     *     length: BorshSchema.u32,
     *     width: BorshSchema.u32,
     *   }),
     *   Circle: BorshSchema.Struct({
     *     radius: BorshSchema.u32,
     *   }),
     * });
     *
     * type Shape = Infer<typeof schema>;
     *
     * // type Shape =
     * //   | {
     * //   Square: number;
     * // }
     * //   | {
     * //   Rectangle: {
     * //     length: number;
     * //     width: number;
     * //   };
     * // }
     * //   | {
     * //   Circle: {
     * //     radius: number;
     * //   };
     * // };
     *
     * const shape: Shape = {
     *   Square: 5,
     * };
     *
     * const buffer = schema.serialize(shape);
     */
    static Enum(variants) {
        const schema = BorshSchema.parseEnumSchema(variants);
        return BorshSchema.fromSchemaUnchecked(schema);
    }
    static parseStructSchema(fields) {
        const entries = Object.entries(fields).map(([key, value]) => [key, value.toSchema()]);
        return {
            struct: Object.fromEntries(entries),
        };
    }
    static parseEnumSchema(variants) {
        return {
            enum: Object.entries(variants).map(([key, value]) => ({
                struct: { [key]: value.toSchema() },
            })),
        };
    }
}
exports.BorshSchema = BorshSchema;
//# sourceMappingURL=schema.js.map